[{"content":"Stonks This challenge was part of the PicoCTF 2021 and was part of the Binary Exploitation genre. It was very fun to solve. Let\u0026rsquo;s start with the examination.\nAvailable files: vuln.c\nExamination After reading a bit of the code we can detect a Format String vulnerability. The interesting function in this program is buy_stonks.\nint buy_stonks(Portfolio *p) {\rif (!p) {\rreturn 1;\r}\rchar api_buf[FLAG_BUFFER];\rFILE *f = fopen(\"api\",\"r\");\rif (!f) {\rprintf(\"Flag file not found. Contact an admin.\\n\");\rexit(1);\r}\rfgets(api_buf, FLAG_BUFFER, f);\rint money = p-\u003emoney;\rint shares = 0;\rStonk *temp = NULL;\rprintf(\"Using patented AI algorithms to buy stonks\\n\");\rwhile (money \u003e 0) {\rshares = (rand() % money) + 1;\rtemp = pick_symbol_with_AI(shares);\rtemp-\u003enext = p-\u003ehead;\rp-\u003ehead = temp;\rmoney -= shares;\r}\rprintf(\"Stonks chosen\\n\");\r// TODO: Figure out how to read token from file, for now just ask\rchar *user_buf = malloc(300 + 1);\rprintf(\"What is your API token?\\n\");\rscanf(\"%300s\", user_buf);\rprintf(\"Buying stonks with token:\\n\");\rprintf(user_buf);\r// TODO: Actually use key to interact with API\rview_portfolio(p);\rreturn 0;\r}\rThe fact that there is a variable called api_buf that stores the flag\u0026rsquo;s contents and is on the stack, alerts us that it might be possible to use some kind of leaking technique, to get the actual flag. As we can see from the picture above, the program reads the contents of the flag from a file called api. The program asks us to enter some input (maximum of 300 bytes) and then prints it using printf() function from libc. A clear Format-String Vulnerability.\nPayload We will enter lots of %xs to leak the flag value on the stack.\nInterpreting The Output Now, this might look like gibrish to us. But all of these values are hexadecimal values, and some of them incoorapte to ascii values. To convert these values to ascii values, we will use the following technique.\n1 echo -n {your-hexadecimal-values} | perl -pe \u0026#39;s/([0-9a-f]{2})/chr hex $1/gie\u0026#39; Source of this method here.\nThis is the output of the above command:\n���H�?���������p��9 !c�ocip{FTC0l_I4_t5m_ll0m_y_y3nbc7ceac6��}��*���T@~�~4Ο�\r�\\���#�~%h������2D�����p��~ ��2x���P����~����2x�H�i!A`��2d��2x�H���?���3,��3$����2��ݯ���p��p}����3$��3,��2���p���\r�M�_��P�0������b�H�Q��3$�H�0���`��3��)@�����\u003e\rNow, the output still looks not so familiar to the human eye. This is because of two reasons:\nThe addresses of this binary are stored in little-endian (and we know that this is a 32-bit binary, by the length of the addresses). We are leaking a lot of addresses from the stack. Lots of them don\u0026rsquo;t have any connection to ascii values. We will need to identify the exact values of the flag. We can do that by looking at the ascii table and determine what is the value of the letter \u0026lsquo;o\u0026rsquo;, which is the start of the little-endian flag that we are looking for. The ascii value is 6f. We can confidently delete all the values up until this value. Little-endian means that the addresses are reversed. Every 4 bytes. \u0026ldquo;pico\u0026rdquo; is the first 4 bytes of our flag and that is why the letter \u0026ldquo;o\u0026rdquo; will be the first letter of it in little-endian. After we do this, we can copy the entire flag up until the character \u0026ldquo;}\u0026rdquo;, and place it in a python program inside a variable. The following python code will help us in reversing the entire flag to be in big-endian and thus be readable for us:\n1 2 3 4 5 6 7 8 9 10 11 12 13 if __name__ == \u0026#39;__main__\u0026#39;: message = \u0026#39;ocip{FTC0l_I4_t5m_ll0m_y_y3nbc7ceac6��}�\u0026#39; new_message = \u0026#34;\u0026#34; count = 0 part_message = \u0026#34;\u0026#34; for _ in message: part_message += _ count += 1 if count == 4: new_message += \u0026#34;\u0026#34;.join((list(reversed(part_message)))) count = 0 part_message = \u0026#34;\u0026#34; print(new_message) After this function, we may take the output and delete all the � characters. The more elegant and maybe better way to do this operation would be to use RegEx.\nWe have the flag!\n","date":"2024-03-31T00:00:00Z","image":"http://localhost:1313/images/2024-thumbs/picoctf-2021-stonks-writeup.jpg","permalink":"http://localhost:1313/posts/Write-ups/picoctf-2021-stonks-writeup/","title":"PicoCTF 2021 Stonks Writeup"},{"content":"format string 0 Hello everyone. Firstly, this challenge is attached to the source code file and the binary itself. You may see this from the files that I provided (except for the binary file, which currently has a download issue. I believe this will be resolved soon.). If you wish to obtain the required flag for this challenge, you would need to connect to the server operating these challenges using the challenge instance, using netcat.\nIn this challenge, we could notice and understand what are the operations required from us to get the flag even without looking at the source code. I noticed that it is quite common among picoCTF challenges to be represented in this form. Of course, I am going to cover the source code as well for our understanding of what\u0026rsquo;s going on under the hood. Let\u0026rsquo;s begin.\nAvailable files: format-string-0.c\nFirst look We connect to the server through the provided instance. In my case:\n1 nc mimas.picoctf.net 64224 We get the following output:\n1 2 3 4 Welcome to our newly-opened burger place Pico \u0026#39;n Patty! Can you help the picky customers find their favorite burger? Here comes the first customer Patrick who wants a giant bite. Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe Enter your recommendation: As we may understand from the challenge name (\u0026ldquo;format string\u0026hellip;\u0026rdquo;) and from the named burgers. We might need to select the named burger that includes a string format specifier. We can see that the second named burger included a string format specifier by the % symbol. Let\u0026rsquo;s select that name and see the result. We get the following output:\n1 2 3 4 5 6 7 Enter your recommendation: Gr%114d_Cheese Gr 4202954_Cheese Good job! Patrick is happy! Now can you serve the second customer? Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!) Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak Enter your recommendation: Now, the reason for the numbers displayed on screen (4202954) is that the string format specifier in the name of the burger we inputted, includes an integer string format specifier (%d):\nGr%114d_Cheese\nThe whole idea of a format string vulnerability is that it enables the attacker to read or write arbitrary data from and to the stack. So when we input this name of burger to the program, we get an integer formed data that is actually from the stack. It may contain valuable data in many cases. The number 114 before the letter \u0026rsquo;d\u0026rsquo; is for the maximum field width. The conversion will stop after the specified number of characters has been processed. For more information read the following discussion on Stackoverflow: https://stackoverflow.com/questions/16231136/what-does-a-number-between-and-format-specifier-mean-in-scanf. Now, the reason for this message: \u0026ldquo;(better be served quick before the shop owner kicks you out!)\u0026rdquo;, is to notify you that if you don\u0026rsquo;t enter an input soon, the connection between your machine and the server will be closed. There is a timeout of connection when using netcat to connect to a server, when there is no input for some time. After that, we need to enter another name of a burger from a list of names of burgers. This time we can see two names that have the % symbol. But we can see that only one name includes a real string format specifier. The first name includes a %t, which is not a real format string specifier. In contrast, the third name includes 3 real format string specifiers of string type. This means that if we enter the name of this burger we would get a string form of data from the stack. I have a hunch that it would be the flag. Let\u0026rsquo;s enter it. After entering this name, we get the following output:\n1 2 3 Enter your recommendation: Cla%sic_Che%s%steak ClaCla%sic_Che%s%steakic_Che(null) picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7} Which includes the required flag. By the way, if we tried to input just format string specifiers, it wouldn\u0026rsquo;t work, because the program checks that the input is one of the three named burgers in the lists provided.\nUnder The Hood Let\u0026rsquo;s examine the important parts of this program (marked in green).\n#define BUFSIZE 32\r#define FLAGSIZE 64\rchar flag[FLAGSIZE];\rint main(int argc, char **argv){\rFILE *f = fopen(\"flag.txt\", \"r\");\rif (f == NULL) {\rprintf(\"%s %s\", \"Please create 'flag.txt' in this directory with your\",\r\"own debugging flag.\\n\");\rexit(0);\r}\rfgets(flag, FLAGSIZE, f);\rsignal(SIGSEGV, sigsegv_handler);\rgid_t gid = getegid();\rsetresgid(gid, gid, gid);\rserve_patrick();\rreturn 0;\r}\rvoid serve_patrick() {\rprintf(\"%s %s\\n%s\\n%s %s\\n%s\",\r\"Welcome to our newly-opened burger place Pico 'n Patty!\",\r\"Can you help the picky customers find their favorite burger?\",\r\"Here comes the first customer Patrick who wants a giant bite.\",\r\"Please choose from the following burgers:\",\r\"Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe\",\r\"Enter your recommendation: \");\rfflush(stdout);\rchar choice1[BUFSIZE];\rscanf(\"%s\", choice1);\rchar *menu1[3] = {\"Breakf@st_Burger\", \"Gr%114d_Cheese\", \"Bac0n_D3luxe\"};\rif (!on_menu(choice1, menu1, 3)) {\rprintf(\"%s\", \"There is no such burger yet!\\n\");\rfflush(stdout);\r} else {\rint count = printf(choice1);\rif (count \u003e 2 * BUFSIZE) {\rserve_bob();\r} else {\rprintf(\"%s\\n%s\\n\",\r\"Patrick is still hungry!\",\r\"Try to serve him something of larger size!\");\rfflush(stdout);\r}\r}\r}\rvoid serve_bob() {\rprintf(\"\\n%s %s\\n%s %s\\n%s %s\\n%s\",\r\"Good job! Patrick is happy!\",\r\"Now can you serve the second customer?\",\r\"Sponge Bob wants something outrageous that would break the shop\",\r\"(better be served quick before the shop owner kicks you out!)\",\r\"Please choose from the following burgers:\",\r\"Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak\",\r\"Enter your recommendation: \");\rfflush(stdout);\rchar choice2[BUFSIZE];\rscanf(\"%s\", choice2);\rchar *menu2[3] = {\"Pe%to_Portobello\", \"$outhwest_Burger\", \"Cla%sic_Che%s%steak\"};\rif (!on_menu(choice2, menu2, 3)) {\rprintf(\"%s\", \"There is no such burger yet!\\n\");\rfflush(stdout);\r} else {\rprintf(choice2);\rfflush(stdout);\r}\r}\r}\rPlease pay attention to the third marked line. At this line, the program copies the contents of flag.txt (f) to the local variable flag. You need to understand that after this line gets executed, the local variable flag is present on the stack, in a register. Now, because there is a problem when downloading the actual binary, we can\u0026rsquo;t run checksec on it. But, because I participated in this CTF and the binary download worked, I can write that this binary is 64-bit. The reason that this is an important detail (for our understanding) is that in 64-bit binaries, the first variables are stored in the registers first - RDI, RSI, RDX, RCX, R8, R9, stack\u0026hellip;, in that order. And, the memory addresses in 64-bit binaries are 8 bytes long (64 bits).\nIf we look at the fifth marked line, we can see that after we enter our choice there is an integer variable that is storing printf(choice1) (choice1 = our input). After that line, the program checks if that variable is greater than two times the size of BUFSIZE which is equal to 64 (as we can calculate from the first marked line). If you recall the number we got when we entered the name of a burger the first time, we got a very large number, 4202954 to be exact. Now, this number alone, without the other characters with it, is greater than 64. That is why the program calls serve_bob() function. This large number is some value from the stack, printed in decimal, it could include the flag, but it isn\u0026rsquo;t clear to us. The reason we get values from the stack in this situation is that the string we input includes format string specifier (%d - Gr%114d_Cheese). And, when the program prints our input without specifying any parameters to the format string specifier, the program prints the values that are present on the stack instead, as the parameters.\nNext, when we input Cla%sic_Che%s%steak, the program then prints the values, without specifying any parameters. And then, takes values off the stack instead, and prints them to us. The number of format string specifiers of type string is enough in this case (3), to print the entire flag value off the stack.\n","date":"2024-03-31T00:00:00Z","image":"http://localhost:1313/images/2024-thumbs/picoctf-2024-fs0-writeup.jpg","permalink":"http://localhost:1313/posts/Write-ups/picoctf-2024-fs0-writeup/","title":"PicoCTF 2024 FS0 Writeup"}]